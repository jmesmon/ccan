#include "config.h"
#include <string.h>

/**
 * bheapm - an intrusive binary heap
 *
 * Each item to be inserted into the heap embeds a 'struct bheapm_node',
 * then uses container_of to find itself. Allows avoiding dynamic allocation of
 * a heap-array.
 *
 * Operations, where n is the number of items in the heap:
 * init:    O(1)
 * push:    O(lg(n))
 * pop:     O(lg(n))
 * peek:    O(1)
 *
 * Example:
 *	#include <stdio.h>
 *
 *	#include <ccan/bheapm/bheapm.h>
 *	#include <ccan/container_of/container_of.h>
 *
 *	struct foo {
 *		int i;
 *		struct bheapm_node n;
 *	};
 *
 *	static int ord_foo(const struct bheapm_ *bh,
 *                         const struct bheapm_node *a,
 *			   const struct bheapm_node *b)
 *	{
 *		return container_of(a, struct foo, n)->i - container_of(b, struct foo, n)->i;
 *	}
 *
 *	int main(void)
 *	{
 *		BHEAPM(struct foo, n) h;
 *		struct foo arr[] = { {1}, {0}, {2} };
 *		int i;
 *
 *		bheapm_init(&h, ord_foo);
 *
 *		for (i = 0; i < 3; i++)
 *			bheapm_push(&h, &arr[i]);
 *
 *		// should print 0, 1, 2
 *		for (i = 0; i < 3; i++) {
 *			printf("%d\n", bheapm_pop(&h)->i);
 *		}
 *		return 0;
 *	}
 *
 * License: LGPL (v3 or any later version)
 * Author: Cody P Schafer <dev@codyps.com>
 */
int main(int argc, char *argv[])
{
	/* Expect exactly one argument */
	if (argc != 2)
		return 1;

	if (strcmp(argv[1], "depends") == 0) {
		printf("ccan/compiler\n");
		printf("ccan/ilog\n");
		printf("ccan/order\n");
		printf("ccan/tcon\n");
		return 0;
	}

        if (strcmp(argv[1], "testdepends") == 0) {
		printf("ccan/container_of\n");
		printf("ccan/array_size\n");
                return 0;
        }

	return 1;
}
